#### 分布式、微服务知识点

> 参考《高可用可伸缩微服务架构》

#####  领域驱动有了解吗？什么是领域驱动模型？

##### JWT有了解吗，什么是JWT

##### 说说如何设计一个良好的 API

##### 说说 CAP 定理、BASE 理论

CAP: 

 C(一致性  Consistency)，所有节点上的数据时刻保持一致

 A(可用性 Avaliability)，每个请求都能够收到一个响应，无论响应成功或者失败

P(分区容错 Partition-tolerance)，系统出现脑裂以后，可能导致某些server 与集群中的机器失去联系

BASE： 

XA事务虽然可以保证数据库在分布式系统下的ACID特性，但会带来性能方面的影响

eBay提出了BASE理论

Basically available：数据库采用分片模式，把100w的用户数据分布在5个实例上，如果破坏了其中一个实例，仍然可以保证80%的用户可用

Soft-state：在基于client-server模式的系统中，server端是否有状态，决定了系统是否具备良好的水平扩展、负载均衡、故障恢复等特性。Server端承诺会维护client端状态数据，这个状态仅维持一小段时间，这段时间以后，server端会丢弃这个状态，恢复正常状态

Eventually consistent：数据最终一致性



##### 微服务与 SOA 的区别

SOA即面向服务架构，关注点是服务，现有的分布式服务化技术有Dubbo等

1. 微服务是一种经过改良架构设计的SOA解决方案，是面向服务的交互方案
2. 微服务更趋向于以自治的方式产生价值
3. 微服务与敏捷开发的思想高度结合在一起，服务的定义更加清晰，同时减少了企业ESB开发的复杂性
4. 微服务是SOA思想的一种提炼
5. SOA是重ESB,微服务是轻网关

##### 如何拆分服务、水平分割、垂直分割

##### 如何应对微服务的链式调用异常

##### 如何快速追踪与定位问题

##### 如何保证微服务的安全、认证



##### 如何保证接口的幂等性

1. 乐观锁，使用版本号

2. 唯一索引，可以把作为唯一索引的键单独称为一个表，作为去重表

3. 分布式锁，使用setnx，如果setnx返回0就代表重复请求，同时在业务逻辑处理完成后，删除缓存

    

##### 分布式服务接口请求的顺序性如何保证？

首先，一般来说，个人建议是，你们从业务逻辑上设计的这个系统最好是不需要这种顺序性的保证，因为一旦引入顺序性保障，比如使用**分布式锁**，会**导致系统复杂度上升**，而且会带来**效率低下**，热点数据压力过大等问题。

下面我给个我们用过的方案吧，简单来说，首先你得用 dubbo 的一致性 hash 负载均衡策略，将比如某一个订单 id 对应的请求都给分发到某个机器上去，接着就是在那个机器上，因为可能还是多线程并发执行的，你可能得立即将某个订单 id 对应的请求扔一个**内存队列**里去，强制排队，这样来确保他们的顺序性。

[<img src="media/distributed-system-request-sequence.png" alt="distributed-system-request-sequence" style="zoom:50%;" />

但是这样引发的后续问题就很多，比如说要是某个订单对应的请求特别多，造成某台机器成**热点**怎么办？解决这些问题又要开启后续一连串的复杂技术方案......曾经这类问题弄的我们头疼不已，所以，还是建议什么呢？

最好是比如说刚才那种，一个订单的插入和删除操作，能不能合并成一个操作，就是一个删除，或者是其它什么，避免这种问题的产生。



##### 说说分布式一致性的实现方案

1. 两阶段提交

    分准备阶段、提交阶段，由事务管理协调器发起

    准备阶段：事务管理器向参与者发起指令，参与者评估自己的状态，如果参与者评估指令可以完成，则会写redo或者undo日志，然后锁定资源，执行操作，但并不提交。如果其中一个参与者返回准备准备失败，则协调者向参与者发起中止指令，参与者取消已经变更的事务，执行undo日志，释放锁定的资源

    提交阶段：如果每个参与者明确返回准备成功，也就是预留资源和执行操作成功，则协调者向参与者发起提交指令，参与者提交资源变更的事务，释放锁定的资源；

    缺点：

    阻塞，对于任何一次指令都必须收到明确的响应，才会继续下一步，否则处于阻塞状态，占用的资源被一直锁定，不会释放

    单点故障，协调者宕机，参与者没有协调者指挥，会一直阻塞，需要自己实现协调者选举

    脑裂，协调者发送指令，有的参与者可能会没有接收到指令，导致多个参与者事务状态不一致

2. 三阶段提交

    是二阶段提交的改进版本，通过超时机制解决了阻塞问题

    询问阶段：协调者询问参与者是否可以完成指令，协调者回复是或者不是，不做真正的操作，如果超时会导致中止

    准备阶段、提交阶段：与二阶段相同

3. TCC补偿事务 

    将一个任务拆分成Try、Confirm、Cancle三个步骤，主业务先发起请求执行Try，如果没有问题，则提交任务到TCC事务管理器，由事务管理器执行Confirm，如果出现问题，再执行逆操作Cancel

    优点：解决了阻塞问题，通过TCC自动化Cancel降低了不一致的情况

    缺点：实现还是臃肿，在极端情况下会出现不一致和脑裂问题

4. RocketMQ事务

    系统A发送一个事务消息到MQ，MQ会反馈消息接收成功，系统A会收到消息接收成功回调，此时系统A执行本地事务，执行成功后向MQ发送确认消息，否则向MQ取消消息，MQ收到确认消息后，消费系统B就能够接收到该事务消息，执行操作

##### 说说达到最终一致性的方案

1. 查询模式，通过查询了解调用服务的最终处理情况，决定下一步做什么
2. 补偿模式，有了查询模式，就可以知道服务所在状态，通过补偿模式修正操作
3. 定时校对模式

##### 缓存、数据库一致性方案

1. 更新操作，先删除缓存，再修改数据库，如果数据库失败，数据库中的还是旧数据，缓存是空的，在查询的时候，发现缓存是空的，就会从数据库取数据，然后更新到缓存中

2. 方案一在高并发下，先删除了缓存，但数据库还没修改成功，此时读请求过来，发现没有缓存，就会去查询数据库，放入缓存，随后更新数据库操作完成了，此时缓存中的数据是旧数据，与数据库中的数据不一致。

    方案如下：

    在请求的时候，发现没有缓存，就发一个更新操作，到JVM队列，主线程循环判断缓存是否更新，并设置超时时间，如果超时，就直接取数据库数据，返回旧数据。JVM队列中，如果之前已经有更新操作，自动丢弃后面的更新操作，防止频繁更新。

    如果实例服务是分布式部署，需要将同一请求路由到同一个实例，可以通过某个请求参数的hash路由，也可以通过Nginx的hash路由功能

##### 